#include <bits/stdc++.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/types.h>
#include <fstream>
#include <ostream>
#include <errno.h>
#include <chrono>
using namespace std;
using namespace std::chrono;

//----- MACROS -----//
#define NUM_PUSH_UPDATE 25
#define NUM_READ_POST 10
#define BUFF_SIZE 300
#define NUM_NODES 40000

//---- Structs and Classes ----//
typedef struct action
{
    int user_id = 0; // user who performed the action
    int action_id = 0; // id of the post, like or comment
    int action_type = 0; // 0 for post, 1 for like, 2 for comment
    uint64_t priority_val = 0; // priority value of the action
    uint64_t timestamp; // time of the action (in milliseconds)
}action;

// custom comparators for feedQueue
// compare the priority values of two actions
struct feed_compare
{
    // sort in descending order of priority
    bool operator() (const action &a, const action &b) const
    {
        return a.priority_val < b.priority_val;
    }
};

class node 
{
    public:
        int user_id = 0; // id of the user
        bool order = -1; // 0 for priority, 1 for chronological
        queue <action> wallQueue; // actions generated by the user
        priority_queue <action, vector<action>, feed_compare> feedQueue; // actions generated by the user's friends (neighbors)
        vector <int> numActions = {0, 0, 0}; // number of actions of each type
    
    // constructor
    node(int id) { 
        user_id = id; 
        order = rand() % 2; // random order
        wallQueue = queue <action> ();
        feedQueue = priority_queue <action, vector<action>, feed_compare> ();
    }
    
    // copy constructor
    node(const node &n) {
        user_id = n.user_id;
        order = n.order;
        wallQueue = n.wallQueue;
        feedQueue = n.feedQueue;
        numActions = n.numActions;
    }
};

//----- Helper Functions -----//

// Print a string to a file using fwrite in given mode
// (to print to stdout, use "stdout" as the file name)
void fileWrite(string file, string str, string mode)
{
    if (file == "stdout") {
        char * buff = new char[str.length() + 1];
        strcpy(buff, str.c_str());
        fwrite(buff, sizeof(char), str.length(), stdout);
    }
    else {
        FILE * fp = fopen(file.c_str(), mode.c_str());
        char * buff = new char[str.length() + 1];
        strcpy(buff, str.c_str());
        fwrite(buff, sizeof(char), str.length(), fp);
        fclose(fp);
    }
}

uint64_t timeSinceEpochMillisec() {
  using namespace std::chrono;
  return duration_cast<milliseconds>(system_clock::now().time_since_epoch()).count();
}

//----- Global Variables -----//
map <int, vector<int>> graph; // graph of users
vector <node> users(NUM_NODES, node(0)); // vector of users (for easy access)

queue <action> actionQueue; // queue of actions (shared between userSimulator and pushUpdate)
queue <int> userQueue; // queue of users (shared between pushUpdate and readPost)

string actionName[3] = {"post" , "like", "comment"};

//----- Graph Functions ----//
void print_graph(string filename)
{
    ofstream out(filename);
    for (auto it = graph.begin(); it != graph.end(); it++)
    {
        out << it->first << " : ";
        for (auto it2 = it->second.begin(); it2 != it->second.end(); it2++) (it2 != it->second.end() - 1)? out << *it2 << ", " : out << *it2 << " ";
        out << endl;
    }
    out.close();
}

void print_nodes(string filename)
{
    ofstream out(filename);
    for (auto it : users)
    {
        out << it.user_id << " : ";
        out << "order: " << it.order << endl;
    }
    out.close();
}

//----- LOCK Functions, CONDS and MUTEXES -----//
// (wrappers for pthread_mutex_lock and pthread_mutex_unlock)
// mutex for actionQueue
pthread_mutex_t actionQueue_mutex;
pthread_cond_t actionQueue_cond;
int AQ_size = 0;

pthread_mutex_t feedQueue_mutex[NUM_NODES];

pthread_mutex_t userQueue_mutex;
pthread_cond_t userQueue_cond;
int UQ_size = 0;

void lock(pthread_mutex_t * lock)
{
    int ret = pthread_mutex_lock(lock);
    if (ret != 0) 
    {
        // print in red
        cout << "\033[1;31m";            // read action
            char * buff = new char[BUFF_SIZE];

        cout << "Error: lock failed!" << endl;
        cout << "\033[0m";
        exit(1);
    }
}
void unlock(pthread_mutex_t * lock)
{
    int ret = pthread_mutex_unlock(lock);
    if (ret != 0) cout << "Error: unlock failed!" << endl;
}

//----- Thread Functions -----//
/*
    userSimulator Thread:
*/
void * userSimulator(void * vars)
{
    while (true)
    {
        fileWrite("stdout", ">> userSimulator Thread awoke\n", "a");
        fileWrite("sns.log", ">> userSimulator Thread awoke\n", "a");

        // choose 100 random nodes
        set <int> chosen;
        while (chosen.size() < 100)
        {
            int x = rand() % graph.size();
            chosen.insert(x);
        }

        // generate actions
        for (auto it : chosen)
        {
            int n = log2(graph[it].size() * 2.0) * 3.0;
            char * buff = new char[BUFF_SIZE];
            sprintf(buff, "\tuserSimulator :: chosen <%d> {degree: %ld , actions: %d}\n", it, graph[it].size(), n);
            fileWrite("stdout", buff, "a");
            fileWrite("sns.log", buff, "a");
            delete buff;

            for (int i = 0; i < n; i++)
            {
                int action_type = rand() % 3;
                users[it].numActions[action_type]++;
                int user_priority = users[it].order;
                int user_degree = graph[it].size();

                // print action
                char * buff = new char[BUFF_SIZE];
                sprintf(buff, "\t\tuserSimulator :: <%d> : %d (%s)\n", it, action_type, actionName[action_type].c_str());
                fileWrite("stdout", buff, "a");
                fileWrite("sns.log", buff, "a");
                delete buff;
                
                // push action to wallQueue
                uint64_t curr_time = timeSinceEpochMillisec();
                users[it].wallQueue.push(action{.user_id = it, .action_id = users[it].numActions[action_type], .action_type = action_type, .priority_val = (user_priority == 0)? user_degree : curr_time, .timestamp = curr_time});

                // push action to actionQueue
                //--- START CRITICAL SECTION
                lock(&actionQueue_mutex);

                actionQueue.push(action{.user_id = it, .action_id = users[it].numActions[action_type], .action_type = action_type, .priority_val = (user_priority == 0)? user_degree : curr_time, .timestamp = curr_time});

                pthread_cond_signal(&actionQueue_cond);
                AQ_size++;
                
                unlock(&actionQueue_mutex);
                //--- END CRITICAL SECTION
            }
        }

        sleep(120);
    }
    pthread_exit(NULL);
}

/*
    pushUpdate Thread: 
*/
void * pushUpdate(void * vars)
{
    sleep(1);
    char * buff = new char[BUFF_SIZE];
    sprintf(buff, ">> pushUpdate Thread awoke\n" );
    fileWrite("stdout", buff, "a");
    fileWrite("sns.log", buff, "a");
    delete buff;

    while (1)
    {
        //--- START CRITICAL SECTION
        lock(&actionQueue_mutex);

        // wait for actionQueue to have an action in it
        while (AQ_size == 0) pthread_cond_wait(&actionQueue_cond, &actionQueue_mutex);

        // pop action from actionQueue
        action a = actionQueue.front();
        actionQueue.pop();
        AQ_size--;

        char * buff = new char[BUFF_SIZE];
        sprintf(buff, "\tpushUpdate :: popped action -> {UserID: %d , ActionID: %d, Action: %d , Timestamp: %ld}\n", a.user_id, a.action_id, a.action_type, a.timestamp);
        fileWrite("stdout", buff, "a");
        fileWrite("sns.log", buff, "a");
        delete buff;
        
        unlock(&actionQueue_mutex);
        //--- END CRITICAL SECTION

        // push action to neighbors
        for (auto it : graph[a.user_id])
        {
            //--- START CRITICAL SECTION
            lock(&feedQueue_mutex[it]);

            // if user's order is 0, change priority_val to number of common friends
            // so the actions of closest friends are prioritized
            if (users[it].order == 0)
            {
                int common = 0;
                for (auto it2 : graph[it])
                {
                    auto iter = find(graph[a.user_id].begin(), graph[a.user_id].end(), it2);
                    if (iter != graph[a.user_id].end()) common++;
                }
                a.priority_val = common;
            }

            users[it].feedQueue.push(a);

            // print action
            char * buff = new char[BUFF_SIZE];
            sprintf(buff, "\t\tpushUpdate :: pushed action <%d> <- {UserID: %d , ActionID: %d, Action: %d , Timestamp: %ld}\n", it, a.user_id, a.action_id, a.action_type, a.timestamp);
            fileWrite("stdout", buff, "a");
            fileWrite("sns.log", buff, "a");
            delete buff;

            unlock(&feedQueue_mutex[it]);
            //--- END CRITICAL SECTION

            //--- START CRITICAL SECTION
            lock(&userQueue_mutex);

            // push user to userQueue
            userQueue.push(it);
            UQ_size++;

            // signal readPost thread
            pthread_cond_signal(&userQueue_cond);

            unlock(&userQueue_mutex);
            //--- END CRITICAL SECTION
        }
    }

    pthread_exit(0);
}

/*
    readPost Thread:
*/
void * readPost(void * vars)
{
    sleep(1);
    char * buff = new char[BUFF_SIZE];
    sprintf(buff, ">> readPost Thread awoke\n" );
    fileWrite("stdout", buff, "a");
    fileWrite("sns.log", buff, "a");
    delete buff;
    
    while (1)
    {
        //---- START CRITICAL SECTION
        lock(&userQueue_mutex);

        // wait for userQueue to have a user in it
        while (UQ_size == 0) pthread_cond_wait(&userQueue_cond, &userQueue_mutex);

        int user_id = userQueue.front();
        userQueue.pop();
        UQ_size--;

        unlock(&userQueue_mutex);
        //---- END CRITICAL SECTION

        //--- START CRITICAL SECTION
        lock(&feedQueue_mutex[user_id]);

        // empty the feedQueue
        while (!users[user_id].feedQueue.empty())
        {
            action a = users[user_id].feedQueue.top();
            users[user_id].feedQueue.pop();

            char * buff = new char[BUFF_SIZE];
            sprintf(buff, "\treadPost :: popped feed <%d> -> {UserID: %d , ActionID: %d, Action: %d , Timestamp: %ld, Priority: %ld}\n", user_id, a.user_id, a.action_id, a.action_type, a.timestamp, a.priority_val);
            fileWrite("stdout", buff, "a");
            fileWrite("sns.log", buff, "a");
            delete buff;
        }

        unlock(&feedQueue_mutex[user_id]);
        //--- END CRITICAL SECTION
    }

    pthread_exit(0);
}

/*
    Main Thread:
*/
signed main()
{   
    // mutex and cond inits
    pthread_mutex_init(&actionQueue_mutex, NULL);
    for (int i = 0; i < NUM_NODES; i++) pthread_mutex_init(&feedQueue_mutex[i], NULL);
    pthread_mutex_init(&userQueue_mutex, NULL);
    pthread_cond_init(&actionQueue_cond, NULL);
    pthread_cond_init(&userQueue_cond, NULL);

    // other inits and file writes
    setvbuf(stdout, NULL, _IONBF, 0);
    srand(time(NULL));
    fileWrite("sns.log", ">> Main Thread awoke\n", "w");  
    fileWrite("stdout", ">> Main Thread awoke\n", "w");

    // fill users vector (user_id = index, order = 0 or 1) 
    // [Update IDs and orders]
    for (int i = 0; i < NUM_NODES; ++i) {
        users[i].order = rand() % 2;
        users[i].user_id = i;
    }

    // load graph
    ifstream file("musae_git_edges.csv");
    string line;

    // skip first line
    getline(file, line);
    while (getline(file, line))
    {
        // read line a and b from "a,b"
        int i = line.find(',');
        int x = stoi(line.substr(0, i));
        int y = stoi(line.substr(i + 1, line.length() - i - 1));

        graph[x].push_back(y);
        graph[y].push_back(x);
    }

    // optional print graph and node orders
    print_graph("graph.txt");
    print_nodes("nodes.txt");

    // create threads
    pthread_t userSimulator_t, pushUpdate_t[NUM_PUSH_UPDATE], readPost_t[NUM_READ_POST];
    pthread_create(&userSimulator_t, NULL, userSimulator, NULL);
    for (int i = 0; i < NUM_PUSH_UPDATE; i++) pthread_create(&pushUpdate_t[i], NULL, pushUpdate, NULL);
    for (int i = 0; i < NUM_READ_POST; i++) pthread_create(&readPost_t[i], NULL, readPost, NULL);

    // wait for threads
    pthread_join(userSimulator_t, NULL);
    for (int i = 0; i < NUM_PUSH_UPDATE; i++) pthread_join(pushUpdate_t[i], NULL);
    for (int i = 0; i < NUM_READ_POST; i++) pthread_join(readPost_t[i], NULL);

    // mutex and cond destroy
    pthread_mutex_destroy(&actionQueue_mutex);
    for (int i = 0; i < NUM_NODES; i++) pthread_mutex_destroy(&feedQueue_mutex[i]);
    pthread_mutex_destroy(&userQueue_mutex);
    pthread_cond_destroy(&actionQueue_cond);
    pthread_cond_destroy(&userQueue_cond);

    return 0;
}
